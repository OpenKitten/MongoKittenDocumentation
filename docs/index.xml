<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MongoDB Swift Driver</title>
    <link>http://docs.openkitten.org/index.xml</link>
    <description>Recent content on MongoDB Swift Driver</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 26 Dec 2016 12:14:08 +0100</lastBuildDate>
    <atom:link href="http://docs.openkitten.org/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Document</title>
      <link>http://docs.openkitten.org/bson/Document/</link>
      <pubDate>Mon, 26 Dec 2016 12:14:08 +0100</pubDate>
      
      <guid>http://docs.openkitten.org/bson/Document/</guid>
      <description>

&lt;h1 id=&#34;document&#34;&gt;Document&lt;/h1&gt;

&lt;p&gt;Document is the primary type of BSON. It&amp;rsquo;s either a Dictionary or Array and allows interaction like a native Swift Dictionary or Array.&lt;/p&gt;

&lt;h2 id=&#34;basic-usage&#34;&gt;Basic Usage&lt;/h2&gt;

&lt;p&gt;Documents are usable like any other Swift dictionary/array. Only you&amp;rsquo;ll need to explicitely specify your variable to be a Document.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let document: Document = [
	&amp;quot;my&amp;quot;: &amp;quot;data&amp;quot;,
	&amp;quot;isAwesome&amp;quot;: true
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let document = [
	&amp;quot;my&amp;quot;: &amp;quot;data&amp;quot;,
	&amp;quot;isAwesome&amp;quot;: true
] as Document
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, if you need an Array, you can use the Array literal.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let arrayDocument = [
	1, 2, 3, 4, 5
]

let arrayDocument2 = [
	&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two restrictions to a Document.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If the Document is a Dictionary, the key &lt;em&gt;must&lt;/em&gt; be a String&lt;/li&gt;
&lt;li&gt;The Value in both the Dictionary and Array for &lt;em&gt;must&lt;/em&gt; be a ValueConvertible.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;However, ValueConvertible is a protocol that, by defaut, supports BSON primitives. BSON Primitives can always be used. And custom types can be ValueConvertible.&lt;/p&gt;

&lt;p&gt;Documents allow various methods of initializing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let document0 = Document()
let document1 = Document(array: ...)
let document2 = Document(dictionaryElements: ...)
let document3 = Document(data: [5, 0, 0, 0, 0])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;They allow actions like an array:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var document: Document = [1, 2, 3, 4, 5]

document.append(6)
document[3] // 4
document.count // 6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or actions like a Dictionary:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var document: Document = [
	&amp;quot;key0&amp;quot;: 0,
	&amp;quot;key1&amp;quot;: 1,
	&amp;quot;key2&amp;quot;: 2,
	&amp;quot;key3&amp;quot;: 3
]

document[&amp;quot;key1&amp;quot;] // 1
document[&amp;quot;key4&amp;quot;] // nil
document[&amp;quot;key4&amp;quot;] = 4
document[&amp;quot;key4&amp;quot;] // 4

document.keys // [&amp;quot;key0&amp;quot;, &amp;quot;key1&amp;quot;, &amp;quot;key2&amp;quot;, &amp;quot;key3&amp;quot;, &amp;quot;key4&amp;quot;]
document.values // [0, 1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dictionary Documents act like you would expect.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let document: Document = [
  &amp;quot;hey&amp;quot;: true,
  &amp;quot;hello&amp;quot;: 3.33
]

for (key, value) in document {
	guard key == &amp;quot;hey&amp;quot; || key == &amp;quot;hello&amp;quot; else {
		fatalError(&amp;quot;Impossible!&amp;quot;)
	}
	
	guard value as? Bool == true || value as? Double == 3.33 else {
		fatalError(&amp;quot;Impossible!&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Array Documents act in a similar way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let document: Document = [true, false, 3.3, false, true]

for (key, value) in document {
	guard [&amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;4&amp;quot;].contains(key) else {
		fatalError(&amp;quot;The key in an array is the position as string number&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Documents can be easily embedded inside each other. Because of this we allow you to easily subscript a Document to access sub-Documents and even deeper layers of the structure using variadic subscripts.&lt;/p&gt;

&lt;p&gt;These subscripts accept Strings (for Dictionary Document keys) and &lt;code&gt;Int&lt;/code&gt;egers (for Array positions or Dictionary positions). These work like you would expect from any other Array or Dictionary.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var document = [
	&amp;quot;subdoc&amp;quot;: [
		&amp;quot;subsubdoc&amp;quot;: [
			&amp;quot;array&amp;quot;: [0, false, true, &amp;quot;henk&amp;quot;]
		] as Document
	] as Document
] as Document

// Get element position 2 from array in subsubdoc in subdoc in document
document[&amp;quot;subdoc&amp;quot;, &amp;quot;subsubdoc&amp;quot;, &amp;quot;array&amp;quot;, 2] // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Document also provides some extra features that are commonly used with BSON:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var document: Document = [
	&amp;quot;key&amp;quot;: true,
	&amp;quot;subdoc&amp;quot;: [
	  &amp;quot;value&amp;quot;: 3
	] as Document
]

document[dotNotated: &amp;quot;subdoc.value&amp;quot;] // 3

document.flattened() // [&amp;quot;key&amp;quot;: true, &amp;quot;subdoc.value&amp;quot;: 3]
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ObjectId</title>
      <link>http://docs.openkitten.org/bson/ObjectId/</link>
      <pubDate>Mon, 26 Dec 2016 12:13:13 +0100</pubDate>
      
      <guid>http://docs.openkitten.org/bson/ObjectId/</guid>
      <description>

&lt;h1 id=&#34;objectid&#34;&gt;ObjectId&lt;/h1&gt;

&lt;p&gt;ObjectId is the primary form of identification in MongoDB. ObjectId is a 12 bytes long identifier consisting of non- pseudo- and fully random components.&lt;/p&gt;

&lt;p&gt;ObjectId contains metadata about the creation date in UNIX epoch time, the machine identifer and process ID that created it as well as a random number that&amp;rsquo;s incremented.&lt;/p&gt;

&lt;p&gt;ObjectId is often represented as a 24-character hexadecimal string which is useful in places like an URL&lt;/p&gt;

&lt;p&gt;I.E. &lt;code&gt;https://example.com/users/1234567890abcdef12345678/profile&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;MongoKitten ObjectId values are easily generated using an empty initializer: &lt;code&gt;ObjectId()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Alternatively they&amp;rsquo;re initializable using a hexadecimal String representation like &lt;code&gt;&amp;quot;1234567890abcdef12345678&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let hexString = &amp;quot;1234567890abcdef12345678&amp;quot;
let objectId = try ObjectId(hexString)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In some cases you might want to know the ObjectIds creation date. You can fetch a &lt;code&gt;Foundation.Date&lt;/code&gt; from the ObjectId using &lt;code&gt;let objectIdCreationDate = myObjectId.epoch&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Last but not least, ObjectIds are hashable, so they&amp;rsquo;re usable for a key in a Dictionary.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let dictionary: [ObjectId: Document] = [
  ObjectId(): ...,
  ObjectId(): ...
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the case of MongoKitten/MongoDB this may be useful when you&amp;rsquo;re creating a cache for information from the database. Instead of re-fetching this data from the database you can identify the data using the ObjectId identifier easily.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ValueConvertible</title>
      <link>http://docs.openkitten.org/bson/ValueConvertible/</link>
      <pubDate>Mon, 26 Dec 2016 12:11:57 +0100</pubDate>
      
      <guid>http://docs.openkitten.org/bson/ValueConvertible/</guid>
      <description>

&lt;h2 id=&#34;valueconvertible&#34;&gt;ValueConvertible&lt;/h2&gt;

&lt;p&gt;ValueConvertible is the backbone of BSON. BSONConvertible is a protocol that allows any existing type to represent itself as BSONPrimitive.&lt;/p&gt;

&lt;p&gt;It requires the implementation of a function with the following signature:
&lt;code&gt;func makeBSONPrimitive() -&amp;gt; BSONPrimitive&lt;/code&gt;, so it requires you to represent the ValueConvertible as a primitive.&lt;/p&gt;

&lt;p&gt;There are a number of BSON Primitives.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Double&lt;/li&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;Document.md&#34;&gt;Document&lt;/a&gt; (Array and Dictionary)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;ObjectId.md&#34;&gt;ObjectId&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Bool&lt;/li&gt;
&lt;li&gt;Int32&lt;/li&gt;
&lt;li&gt;Int64&lt;/li&gt;
&lt;li&gt;Binary&lt;/li&gt;
&lt;li&gt;Decimal128&lt;/li&gt;
&lt;li&gt;JavascriptCode&lt;/li&gt;
&lt;li&gt;Null (not nil)&lt;/li&gt;
&lt;li&gt;Date (from Foundation)&lt;/li&gt;
&lt;li&gt;MinKey&lt;/li&gt;
&lt;li&gt;MaxKey&lt;/li&gt;
&lt;li&gt;NSRegularExpression (or RegularExpression on Linux)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Document does not exclusively interact with BSONPrimitives but with ValueConvertibles instead.&lt;/p&gt;

&lt;p&gt;Normally you can create a Document like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let document: Document = [
	&amp;quot;name&amp;quot;: &amp;quot;henk&amp;quot;,
	&amp;quot;age&amp;quot;: 24,
	&amp;quot;awesome&amp;quot;: true,
	&amp;quot;subdocument&amp;quot;: [
		&amp;quot;creation&amp;quot;: Date(),
		&amp;quot;modification&amp;quot;: Date()
	] as Document
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By conforming your type to ValueConvertible you can embed your custom types as BSON type and directly embed them.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct MutationDate: ValueConvertible {
	var creation = Date()
	var modification = Date()
	
	func makeBSONPrimitive() -&amp;gt; BSONPrimitive {
		return [
			&amp;quot;creation&amp;quot;: self.creation
			&amp;quot;moficiation&amp;quot;: moficiation
		] as Document
	}
}

let document: Document = [
	&amp;quot;name&amp;quot;: &amp;quot;henk&amp;quot;,
	&amp;quot;age&amp;quot;: 24,
	&amp;quot;awesome&amp;quot;: true,
	&amp;quot;subdocument&amp;quot;: MutationDate()
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This doesn&amp;rsquo;t sound like much but helps when you have custom objects that aren&amp;rsquo;t already representable as BSON.&lt;/p&gt;

&lt;p&gt;A password needs to be hashed, but needs it&amp;rsquo;s salt, iterations and possibly the algorithm stored. The password ans salt can be binary, the iterations an Int32 or Int64 and thethe algorithm can be defined as a String. All come together in a Document, but you&amp;rsquo;ll need this password to be a part of a User Document, so the password needs to be embeddable in the root Document. Last, but not least, you&amp;rsquo;ll want to have functions on this password that will validate against inputted passwords on a website for example.&lt;/p&gt;

&lt;p&gt;This is a good use case for compliance to ValueConvertible.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>BSONPrimitive</title>
      <link>http://docs.openkitten.org/bson/BSONPrimitive/</link>
      <pubDate>Mon, 26 Dec 2016 12:09:53 +0100</pubDate>
      
      <guid>http://docs.openkitten.org/bson/BSONPrimitive/</guid>
      <description>

&lt;h1 id=&#34;bsonprimitive&#34;&gt;BSONPrimitive&lt;/h1&gt;

&lt;p&gt;BSON is based upon a set of primitive types. These are described &lt;a href=&#34;http://bsonspec.org/spec.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this BSON library we contain a protocol: &lt;code&gt;BSONPrimitive&lt;/code&gt;. This protocol is public and should normally &lt;em&gt;not&lt;/em&gt; be implemented on an existing object.&lt;/p&gt;

&lt;p&gt;This protocol is here to support all native Swift types that are related to an existing MongoDB type. Examples of this would be &lt;code&gt;Int&lt;/code&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;code&gt;String&lt;/code&gt;, but also custom BSON types like &lt;code&gt;JavascriptCode&lt;/code&gt; and &lt;code&gt;Binary&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;BSONPrimitives are representable as BSON binary data that can be put into the Value position of a(n) (array-)Document.&lt;/p&gt;

&lt;p&gt;These primitives also have a typeIdentifier that identifies the type of the binary data.&lt;/p&gt;

&lt;p&gt;Adding custom types that does not conform to an unsupported/custom version of the BSON specification will &lt;em&gt;not&lt;/em&gt; be deserialized and will result in corrupt data.&lt;/p&gt;

&lt;p&gt;The list of BSON Primitives:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Double&lt;/li&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.openkitten.org/bson/Document/&#34;&gt;Document&lt;/a&gt; (Array and Dictionary)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.openkitten.org/bson/ObjectId/&#34;&gt;ObjectId&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Bool&lt;/li&gt;
&lt;li&gt;Int32&lt;/li&gt;
&lt;li&gt;Int64&lt;/li&gt;
&lt;li&gt;Binary&lt;/li&gt;
&lt;li&gt;Decimal128&lt;/li&gt;
&lt;li&gt;JavascriptCode&lt;/li&gt;
&lt;li&gt;Null (not nil)&lt;/li&gt;
&lt;li&gt;Date (from Foundation)&lt;/li&gt;
&lt;li&gt;MinKey&lt;/li&gt;
&lt;li&gt;MaxKey&lt;/li&gt;
&lt;li&gt;NSRegularExpression (or RegularExpression on Linux)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>BSON</title>
      <link>http://docs.openkitten.org/bson/BSON/</link>
      <pubDate>Mon, 26 Dec 2016 12:07:42 +0100</pubDate>
      
      <guid>http://docs.openkitten.org/bson/BSON/</guid>
      <description>

&lt;h2 id=&#34;a-native-fast-bson-library-for-swift-written-in-swift&#34;&gt;A native, fast BSON library for Swift, written in Swift.&lt;/h2&gt;

&lt;p&gt;BSON is parsed and generated as specified for version 1.0 of the &lt;a href=&#34;http://bsonspec.org/spec.html&#34;&gt;BSON specification&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;compatibility&#34;&gt;Compatibility&lt;/h3&gt;

&lt;h5 id=&#34;operating-systems&#34;&gt;Operating systems&lt;/h5&gt;

&lt;p&gt;All versions starting with BSON 1.3 are compatible with OS X and Ubuntu 15.10. Other operating systems may work but are untested.&lt;/p&gt;

&lt;h5 id=&#34;swift-version&#34;&gt;Swift Version&lt;/h5&gt;

&lt;p&gt;We support the Swift version specified in .swift_version, which most of the time is the latest version of Swift when a version is released.&lt;/p&gt;

&lt;p&gt;For every new Swift snapshot we release a new minor version.&lt;/p&gt;

&lt;h3 id=&#34;usage&#34;&gt;Usage&lt;/h3&gt;

&lt;p&gt;The supported method for using this library is trough the Swift Package manager, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import PackageDescription

let package = Package(
    name: &amp;quot;MyApp&amp;quot;,
    dependencies: [.Package(url: &amp;quot;https://github.com/OpenKitten/BSON.git&amp;quot;, majorVersion: 4)]
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;basic-usage&#34;&gt;Basic Usage&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Create a document using a dictionary literal
let document: Document = [
            &amp;quot;hello&amp;quot;: &amp;quot;I am a BSON document&amp;quot;,
            &amp;quot;temperature&amp;quot;: 42.5
        ]

// Retreive the BSON data, ready for storing or sending over the network
let data = document.bsonData // Array of [UInt8]

// Initialize a document using a [UInt8]
let sameDocument = try! Document(data: data)

// Do something with the data
let temperature = document[&amp;quot;temperature&amp;quot;] as Double?

// Use the temperature
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;embedded-documents&#34;&gt;Embedded documents&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let document: Document = [
            &amp;quot;subdocument&amp;quot;: [&amp;quot;hello&amp;quot;: &amp;quot;sample&amp;quot;] as Document,
            &amp;quot;anothersubdocument&amp;quot;: [81.2, &amp;quot;cheese&amp;quot;] as Document // an array is also an embedded document
        ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;comparing&#34;&gt;Comparing&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;document[&amp;quot;double&amp;quot;] == document[&amp;quot;int64&amp;quot;] // true for Double(0) == Int64(0)
document[&amp;quot;double&amp;quot;] === document[&amp;quot;int64&amp;quot;] // false for Double(0) === Int64(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;supported-types&#34;&gt;Supported Types&lt;/h3&gt;

&lt;p&gt;All non-deprecated BSON 1.0 types are supported.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Double&lt;/li&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;li&gt;Document&lt;/li&gt;
&lt;li&gt;Array&lt;/li&gt;
&lt;li&gt;ObjectId&lt;/li&gt;
&lt;li&gt;Bool&lt;/li&gt;
&lt;li&gt;DateTime&lt;/li&gt;
&lt;li&gt;32-bit integer&lt;/li&gt;
&lt;li&gt;64-bit integer&lt;/li&gt;
&lt;li&gt;Null value&lt;/li&gt;
&lt;li&gt;Binary&lt;/li&gt;
&lt;li&gt;Regular Expression&lt;/li&gt;
&lt;li&gt;Min Key&lt;/li&gt;
&lt;li&gt;Max Key&lt;/li&gt;
&lt;li&gt;Timestamp&lt;/li&gt;
&lt;li&gt;Javascript Code&lt;/li&gt;
&lt;li&gt;Javascript Code with Scope&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;supported-features&#34;&gt;Supported features&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;MongoDB Extended JSON&lt;/li&gt;
&lt;li&gt;ISO8601 for Extended JSON Dates&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Really&lt;/strong&gt; fast BSON Parsing and Serializing&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Aggregation</title>
      <link>http://docs.openkitten.org/tutorials/aggregation/</link>
      <pubDate>Wed, 14 Dec 2016 12:36:56 +0000</pubDate>
      
      <guid>http://docs.openkitten.org/tutorials/aggregation/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Authentication</title>
      <link>http://docs.openkitten.org/tutorials/connect/authenticating/</link>
      <pubDate>Wed, 14 Dec 2016 12:36:56 +0000</pubDate>
      
      <guid>http://docs.openkitten.org/tutorials/connect/authenticating/</guid>
      <description>

&lt;h1 id=&#34;authentication&#34;&gt;Authentication&lt;/h1&gt;

&lt;p&gt;Authentication is done using by either providing a MongoDB connection string or a ClientSettings object.&lt;/p&gt;

&lt;h2 id=&#34;mongodb-connection-string&#34;&gt;MongoDB connection String&lt;/h2&gt;

&lt;p&gt;Authentication via a connection String requires the username and password on the left side of the hostname like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let database = try Database(mongoURL: &amp;quot;mongodb://user:password@hostname&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The username and password need to be URL percent encoded.&lt;/p&gt;

&lt;h3 id=&#34;query-parameters&#34;&gt;Query Parameters&lt;/h3&gt;

&lt;p&gt;You can enable SSL with the query parameter &lt;code&gt;ssl&lt;/code&gt; as described [here.](&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CRUD Operations</title>
      <link>http://docs.openkitten.org/tutorials/Cursor/</link>
      <pubDate>Wed, 14 Dec 2016 12:36:56 +0000</pubDate>
      
      <guid>http://docs.openkitten.org/tutorials/Cursor/</guid>
      <description>

&lt;h1 id=&#34;cursor&#34;&gt;Cursor&lt;/h1&gt;

&lt;p&gt;All larger result sets in MongoKitten are encapsulated in a Cursor.&lt;/p&gt;

&lt;p&gt;Cursors are a pointer to a set of data on the MongoDB instance, not locally in-memory.
When looped over the cursor&amp;rsquo;s contents the Cursor will fetch a batch X Documents from the server and make them available to the user. Whenever more are requested the Cursor will fetch the next batch of Documents. The amount of Documents fetched at a time is configurable in most commands with a &lt;code&gt;withBatchSize&lt;/code&gt; parameter.&lt;/p&gt;

&lt;p&gt;A big amount of Documents could benefit enormously from &lt;code&gt;withBatchSize&lt;/code&gt; at 1000 but the Document grouped together may not be bigger than 48MB. Luckily, this rarely happens unless you store binary data like images inside the Documents. A batchSize of 1000 would still leave 48KB of data per Document.&lt;/p&gt;

&lt;h2 id=&#34;mapping-transforming&#34;&gt;Mapping/Transforming&lt;/h2&gt;

&lt;p&gt;When you&amp;rsquo;re executing a &lt;code&gt;find&lt;/code&gt; command on a Collection, it&amp;rsquo;s likely this collection stores data of a certain type. Like all users, all articles etc. For this purpose Cursor has a mechanism to map incoming Documents to other types or even those other types to more specialized types.&lt;/p&gt;

&lt;p&gt;Assuming you have stored &lt;code&gt;Cursor&amp;lt;Document&amp;gt;&lt;/code&gt; received from calling a &lt;code&gt;find&lt;/code&gt; method on Collection:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import BSON
import MongoKitten

struct User {
  let username: String
  init?(fromDocument document: Document) {
    guard let username = document[&amp;quot;username&amp;quot;] as String? else {
      return nil
    }

    self.username = username
  }
}

let usersCursor = Cursor(basicDocumentCursor) { document in
  return User(fromDocument: document)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>CRUD Operations</title>
      <link>http://docs.openkitten.org/tutorials/crud/</link>
      <pubDate>Wed, 14 Dec 2016 12:36:56 +0000</pubDate>
      
      <guid>http://docs.openkitten.org/tutorials/crud/</guid>
      <description>

&lt;h1 id=&#34;crud&#34;&gt;CRUD&lt;/h1&gt;

&lt;p&gt;In &lt;a href=&#34;No page found with path or logical name &#34;tutorials/connect.md&#34;.
&#34;&gt;the setup guide&lt;/a&gt; we&amp;rsquo;ve covered how you can open a Database and from there a Collection. Collections are the storage place in MongoDB like tables for SQL databases.&lt;/p&gt;

&lt;p&gt;From a collection object we can start interacting with our data. From here we&amp;rsquo;ll cover all parts of CRUD.
(Create, Read, Update, Delete). And we&amp;rsquo;ll assume you have a Collection available as the variable &lt;code&gt;collection&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;creation&#34;&gt;Creation&lt;/h2&gt;

&lt;p&gt;You can create an entry in MongoDB by &lt;code&gt;insert&lt;/code&gt;ing a Document into a Collection.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;let identifier = try collection.insert(document)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The returned identifier is the &lt;code&gt;_id&lt;/code&gt; field in the Document. If no &lt;code&gt;_id&lt;/code&gt; exists in the provided Document parameter an ObjectId will be generated. The &lt;code&gt;_id&lt;/code&gt; field can be of almost any value.&lt;/p&gt;

&lt;p&gt;ObjectId keeps track of the creation date and is unique. Int32 and Int64 can be used incrementally like is usual in SQL. Strings can also be used. When you&amp;rsquo;re inserting a Document which primarily contains a unique String (like a database migration&amp;rsquo;s description) this description can be the &lt;code&gt;_id&lt;/code&gt; of the Document.&lt;/p&gt;

&lt;p&gt;No two Documents can exist in the same collection with the same &lt;code&gt;_id&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can also insert an array of Documents which will all be inserted. MongoKitten will return an array of identifiers for each inserted Document.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;let identifiers = try collection.insert([document0, document1, document2])&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;reading-finding&#34;&gt;Reading/finding&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;find&lt;/code&gt; can be ran without arguments to fetch every Document in the collection.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;try collection.find()&lt;/code&gt; will return a &lt;a href=&#34;http://docs.openkitten.org/tutorials/Cursor/&#34;&gt;Cursor&lt;/a&gt; containing all Documents. Cursors are an important part of the MongoKitten flow but we&amp;rsquo;ll cover them in short here.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;try collection.findOne()&lt;/code&gt; will return a single &lt;code&gt;Document?&lt;/code&gt;. Which is nil if no Document could be found.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Array&lt;/code&gt; initializer can be used on the Cursor to create an &lt;code&gt;Array&amp;lt;Document&amp;gt;&lt;/code&gt; containing all results.
This is recommended when you definitely need all results. Looping over a Cursor is recommended when you don&amp;rsquo;t necessarily need all results and might stop in the middle of the process. &lt;code&gt;Array&lt;/code&gt; isn&amp;rsquo;t any better than Cursor other than providing the ability to count the results without an extra query. However, it does use more RAM.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let documentArray = Array(try collection.find())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can specify 6 parameters which we&amp;rsquo;ll all cover underneath which, of course, can be combined.&lt;/p&gt;

&lt;h3 id=&#34;matching&#34;&gt;matching&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;find&lt;/code&gt; accepts a Query that Documents are matched against. You can create a Query from a Document or using operators.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let document = [
  &amp;quot;username&amp;quot;: &amp;quot;bob&amp;quot;
]
let query = Query(document)

try collection.find(matching: query)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let query: Query = &amp;quot;username&amp;quot; == &amp;quot;bob&amp;quot;

try collection.find(matching: query)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sortedby&#34;&gt;sortedBy&lt;/h3&gt;

&lt;p&gt;This accepts a &lt;code&gt;Sort&lt;/code&gt; object which can be created with a Dictionary literal.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let sort: Sort = [
  &amp;quot;integer&amp;quot;: .ascending,
  &amp;quot;date&amp;quot;: .descending
]

try collection.find(sortedBy: sort)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;projecting&#34;&gt;projecting&lt;/h3&gt;

&lt;p&gt;Accepts a projection that projects the fields that should be returned. The &lt;code&gt;_id&lt;/code&gt; key will be included unless specifically disabled.&lt;/p&gt;

&lt;p&gt;Suppose the following Document resides in the database:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let document: Document = [
  &amp;quot;_id&amp;quot;: ObjectId(&amp;quot;abcdefabcdefabcdefabcdef&amp;quot;),
  &amp;quot;key0&amp;quot;: &amp;quot;henk&amp;quot;,
  &amp;quot;key1&amp;quot;: true,
  &amp;quot;key2&amp;quot;: 3,
  &amp;quot;key3&amp;quot;: [
    &amp;quot;key4&amp;quot;: &amp;quot;value0&amp;quot;
  ]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following projection will return the keys &lt;code&gt;_id&lt;/code&gt;, &lt;code&gt;key1&lt;/code&gt; and &lt;code&gt;key2&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let projection: Projection = [&amp;quot;key1&amp;quot;, &amp;quot;key2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following projections will return &lt;code&gt;key2&lt;/code&gt; and &lt;code&gt;key3&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let projection0: Projection = [
  &amp;quot;_id&amp;quot;: false,
  &amp;quot;key2&amp;quot;: true,
  &amp;quot;key3&amp;quot;: true
]

let projection1: Projection = [
  &amp;quot;_id&amp;quot;: .excluded,
  &amp;quot;key2&amp;quot;: .included,
  &amp;quot;key3&amp;quot;: .included
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Applying this projection to limit the returned fields is simple:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;try collection.find(projecting: projection)
try collection.find(projecting: [&amp;quot;_id&amp;quot;: false, &amp;quot;key0&amp;quot;: true])
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;skipping&#34;&gt;skipping&lt;/h3&gt;

&lt;p&gt;Accepts an Int32 that skips the first X results where X is the provided number. If 5 documents match the find query and the skip is set so 4, the last Document is returned. If the skip is set to 2, the last 3 documents will be returned. If the skip is set to 5, no Documents will be returned.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;try collection.find(skipping: 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;limitedto&#34;&gt;limitedTo&lt;/h3&gt;

&lt;p&gt;Accepts an Int32 that limits the returned results to be less or equal to the limit. If 5 documents match the find query and the limit is set to 7, 5 Documents will be returned. If the limit is set to 3, the first 3 Documents will be returned.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;try collection.find(limitedTo: 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;withbatchsize&#34;&gt;withBatchSize&lt;/h3&gt;

&lt;p&gt;The batch size is important with respect to efficiency and performance. Cursors return &lt;code&gt;batchSize&lt;/code&gt; of Documents with every fetch. And a fetch is done whenever more Documents are required. When looping over a cursor containing 100 Documents with a batchSize of 10, 10 queries will be done to fetch all results. The default value is 10 Documents per query because a Document can be up to 16 MB and MongoDB usually only communicates 48 MB per message.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re fetching a lot of small Documents a higher batchSize is useful. If you&amp;rsquo;re fetching a lot of big Documents, a smaller batchSize is necessary. And if you&amp;rsquo;re fetching and processing all Documents like &lt;code&gt;Array(collection.find(...))&lt;/code&gt; or a &lt;code&gt;for document in collection.find(...)&lt;/code&gt; that doesn&amp;rsquo;t break out of the loop it&amp;rsquo;s generally better to fetch more Documents per query to reduce the amount of communication and delay.&lt;/p&gt;

&lt;p&gt;Most MongoDB servers don&amp;rsquo;t accept values over 1000.&lt;/p&gt;

&lt;h2 id=&#34;updating&#34;&gt;Updating&lt;/h2&gt;

&lt;p&gt;Update comes in two forms. Bulk and single updates.&lt;/p&gt;

&lt;h3 id=&#34;single-updates&#34;&gt;Single updates&lt;/h3&gt;

&lt;p&gt;Single updates are formed using a single filter (&lt;a href=&#34;http://docs.openkitten.org/tutorials/QueryBuilder/&#34;&gt;Query&lt;/a&gt; object) and a single update document.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.openkitten.org/tutorials/QueryBuilder/&#34;&gt;Queries are covered here.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Update finds already existing Documents in the collection that match the query/filter and updates them to the &lt;code&gt;to&lt;/code&gt; Document and will overwrite the existing Document with the new Document.&lt;/p&gt;

&lt;p&gt;Assuming the following Document resides in the database:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let document: Document = [
  &amp;quot;_id&amp;quot;: ObjectId(&amp;quot;abcdefabcdefabcdefabcdef&amp;quot;),
  &amp;quot;key0&amp;quot;: &amp;quot;henk&amp;quot;,
  &amp;quot;key1&amp;quot;: true,
  &amp;quot;key2&amp;quot;: 3,
  &amp;quot;key3&amp;quot;: [
    &amp;quot;key4&amp;quot;: &amp;quot;value0&amp;quot;
  ]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Executing the following query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let document = [
  &amp;quot;key0&amp;quot;: &amp;quot;bob&amp;quot;,
  &amp;quot;key1&amp;quot;: false
]

try collection.update(matching: &amp;quot;_id&amp;quot; == ObjectId(&amp;quot;abcdefabcdefabcdefabcdef&amp;quot;), to: document)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Will result in the following database Document:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let document = [
  &amp;quot;_id&amp;quot;: ObjectId(&amp;quot;abcdefabcdefabcdefabcdef&amp;quot;),
  &amp;quot;key0&amp;quot;: &amp;quot;bob&amp;quot;,
  &amp;quot;key1&amp;quot;: false
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However the following query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let document = [
  &amp;quot;$set&amp;quot;: [
    &amp;quot;key0&amp;quot;: &amp;quot;bob&amp;quot;,
    &amp;quot;key1&amp;quot;: false
  ]
]

try collection.update(matching: &amp;quot;_id&amp;quot; == ObjectId(&amp;quot;abcdefabcdefabcdefabcdef&amp;quot;), to: document)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Will result in the following Document.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let document: Document = [
  &amp;quot;_id&amp;quot;: ObjectId(&amp;quot;abcdefabcdefabcdefabcdef&amp;quot;),
  &amp;quot;key0&amp;quot;: &amp;quot;bob&amp;quot;,
  &amp;quot;key1&amp;quot;: false,
  &amp;quot;key2&amp;quot;: 3,
  &amp;quot;key3&amp;quot;: [
    &amp;quot;key4&amp;quot;: &amp;quot;value0&amp;quot;
  ]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;upserting&#34;&gt;upserting&lt;/h3&gt;

&lt;p&gt;If &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;to&lt;/code&gt; Document will be inserted if no matching Documents were found to update.&lt;/p&gt;

&lt;h3 id=&#34;multiple&#34;&gt;multiple&lt;/h3&gt;

&lt;p&gt;If &lt;code&gt;true&lt;/code&gt;, this operation will update &lt;em&gt;all&lt;/em&gt; Documents matching the filter to the &lt;code&gt;to&lt;/code&gt; Document. If &lt;code&gt;$set&lt;/code&gt; is used to overwrite only the &lt;code&gt;$set&lt;/code&gt; key-value pairs, all Documents matching will have the keys overridden. Otherwise the new &lt;code&gt;to&lt;/code&gt; Document will be used for all matching Documents and all non-matching keys will be removed.&lt;/p&gt;

&lt;h3 id=&#34;multiple-updates&#34;&gt;Multiple updates&lt;/h3&gt;

&lt;p&gt;TODO for signature&lt;/p&gt;

&lt;p&gt;&lt;code&gt;public func update(_ updates: [(filter: Query, to: Document, upserting: Bool, multiple: Bool)], stoppingOnError ordered: Bool? = nil) throws -&amp;gt; Int {&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;counting&#34;&gt;Counting&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;count&lt;/code&gt; can be used on a collection to count all Documents matching the provided requirements. If no requirements are provided, all documents will be counted.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;count&lt;/code&gt; will return the amount of updated matches.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;try collection.count() // returns 5
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;matching-1&#34;&gt;matching&lt;/h3&gt;

&lt;p&gt;Count accepts the parameter &lt;code&gt;matching&lt;/code&gt; which requires a Query to be provided.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;try collection.count(matching: &amp;quot;first_name&amp;quot; == &amp;quot;Joannis&amp;quot;) // returns 1 if only one user is named Joannis
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;limitedto-1&#34;&gt;limitedTo&lt;/h3&gt;

&lt;p&gt;Limits the results that will be counted.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;try collection.count(limitedTo: 4) // returns 4, even if 5 users reside in the database
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;skipping-1&#34;&gt;skipping&lt;/h3&gt;

&lt;p&gt;Skips X matching documents before counting.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;try collection.count(skipping: 3) // returns 2, even if 5 users reside in the database
try collection.count(limitedTo: 2, skipping: 4) // Will return 1 in this scenario. 4 will be skipped and only 1 remains to be counted.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;removing&#34;&gt;Removing&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;remove&lt;/code&gt; removes all Documents matching the query but can be limited in the amount of removals. It will return the amount of objects that have been removed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;try collection.remove() // returns 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above example will remove all Documents.&lt;/p&gt;

&lt;h3 id=&#34;matching-2&#34;&gt;matching&lt;/h3&gt;

&lt;p&gt;Acts like all other matchers and expects a Query object. Only Documents matching the Query will be removed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;try collection.remove(matching: &amp;quot;first_name&amp;quot; == &amp;quot;Joannis&amp;quot;) // Returns 1, only one user named &amp;quot;Joannis&amp;quot; exists
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;limitedto-2&#34;&gt;limitedTo&lt;/h3&gt;

&lt;p&gt;Will not return more than X Documents from the collection, even if more Documents match. Will return the first created Documents first.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;try collection.remove(limitedTo: 3) // returns 3, even if 5 or more Documents exist
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Collections</title>
      <link>http://docs.openkitten.org/tutorials/collections/</link>
      <pubDate>Wed, 14 Dec 2016 12:36:56 +0000</pubDate>
      
      <guid>http://docs.openkitten.org/tutorials/collections/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Connect to MongoDB</title>
      <link>http://docs.openkitten.org/tutorials/connect/</link>
      <pubDate>Wed, 14 Dec 2016 12:36:56 +0000</pubDate>
      
      <guid>http://docs.openkitten.org/tutorials/connect/</guid>
      <description>

&lt;h2 id=&#34;setup&#34;&gt;Setup&lt;/h2&gt;

&lt;p&gt;MongoKitten is initializable on Server or Database level. Server objects allow access to every database - if the account you use to authenticate has the permissions to - and is generally not used.&lt;/p&gt;

&lt;p&gt;Database is initializable separately and allows access to a single database on a MongoDB server. You can still access the server object from the Database and access other parts of the server via there if this is necessary.&lt;/p&gt;

&lt;p&gt;You can instantiate a Server using a MongoDB connection URL/String:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let server = try Server(mongoURL: &amp;quot;mongodb://localhost&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The database also has two initializers. One accepts a connection URL as String. The database which is accessed is equal to the authentication database in this case.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let database = try Database(mongoURL: &amp;quot;mongodb://user:password@ds12345-a0.domain.com:25078,ds12345-a1.domain.com:25078/kitten?replicaSet=rs-ds125078&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively you can create a server object and select the database from there:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let server = try Server(mongoURL: &amp;quot;mongodb://localhost&amp;quot;)

let database = server[&amp;quot;my-database-name&amp;quot;]
let database = Database(named: &amp;quot;my-database-name&amp;quot;, atServer: server)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Last but not least you can select a collection/table within a database:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let usersCollection = database[&amp;quot;users&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From here you can interact with every part of MongoKitten.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Connection Options</title>
      <link>http://docs.openkitten.org/reference/connecting/</link>
      <pubDate>Wed, 14 Dec 2016 12:36:56 +0000</pubDate>
      
      <guid>http://docs.openkitten.org/reference/connecting/</guid>
      <description>

&lt;h1 id=&#34;url&#34;&gt;URL&lt;/h1&gt;

&lt;p&gt;Before we go into much further detail we&amp;rsquo;ll cover the concept and structure of a MongoDB connection URL.&lt;/p&gt;

&lt;p&gt;The most basic example of this would be &lt;code&gt;mongodb://localhost&lt;/code&gt;. This consists of the schema (&lt;code&gt;mongodb://&lt;/code&gt; which is required in all MongoDB connection URLs) as well as the hostname, in this case, &lt;code&gt;localhost&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The hostname can be either an IP address or a full address like &lt;code&gt;example.com&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Hostnames can be succeeded by a semicolon &lt;code&gt;:&lt;/code&gt; and a port. A port is a number between 0 and 66535. By default MongoDB is hosted on 27017 which is used by default.&lt;/p&gt;

&lt;p&gt;In the URL you can also add the username and password and authentication database.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mongodb://usern4m3:p455word@example.com:12345/admin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In this example the hostname is &lt;code&gt;example.com&lt;/code&gt;. The instance should be hosted at port &lt;code&gt;12345&lt;/code&gt; and we&amp;rsquo;re authenticating at the username &lt;code&gt;usern4m3&lt;/code&gt; and the password &lt;code&gt;p455word&lt;/code&gt;. The username and password should be URL percent encoded and the authentication database is &lt;code&gt;admin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Last but not least we can specify multiple hosts in the case of a replica set.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mongodb://username:password@host0.example.com:12345,host1.example.com:54321,host2.example.com:27017/admin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In this example we&amp;rsquo;re connecting to a replica set of 3 hosts.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;host0.example.com:12345&lt;/li&gt;
&lt;li&gt;host1.example.com:54321&lt;/li&gt;
&lt;li&gt;host2.example.com:27017&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;query-parameters&#34;&gt;Query parameters&lt;/h3&gt;

&lt;p&gt;After the URL&amp;rsquo;s path (the database) you can optionally add Query parameters.&lt;/p&gt;

&lt;p&gt;These are started with a question mark (&lt;code&gt;?&lt;/code&gt;) and have key-value pairs. Pairs are separated by an ampersand (&lt;code&gt;&amp;amp;&lt;/code&gt;). Every key-value pair has a key which is a string &lt;em&gt;without&lt;/em&gt; &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt; or &lt;code&gt;=&lt;/code&gt; characters (unless percent encoded) which is then followed by an equals sign (&lt;code&gt;=&lt;/code&gt;), followed by a value. The &lt;code&gt;=&lt;/code&gt; and value are optional for some parameters.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mongodb://localhost?ssl&amp;amp;authSource=admin&amp;amp;authMechanism=MONGODB-CR&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This URL has three keys:
- ssl
- authSource
- authMechanism&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ssl&lt;/code&gt; doesn&amp;rsquo;t have a value&lt;/li&gt;
&lt;li&gt;&lt;code&gt;authSource&lt;/code&gt; has the value &lt;code&gt;admin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;authMechanism&lt;/code&gt; has the value &lt;code&gt;MONGODB-CR&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ssl&#34;&gt;SSL&lt;/h3&gt;

&lt;p&gt;SSL is enabled for a server by adding the query parameter key &lt;code&gt;ssl&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mongodb://mongodb.example.com:12345/myDatabase?ssl&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;authsource&#34;&gt;authSource&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;authSource&lt;/code&gt; indicates that the authentication database differs from the default (admin) or the selected database in the path.&lt;/p&gt;

&lt;p&gt;Where &lt;code&gt;mongodb://mongodb.example.com:12345/myDatabase&lt;/code&gt; will use &lt;code&gt;myDatabase&lt;/code&gt; for authentication and &lt;code&gt;mongodb://mongodb.example.com:12345&lt;/code&gt; will use &lt;code&gt;admin&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mongodb://mongodb.example.com:12345/myDatabase?authSource=test&lt;/code&gt; will use &lt;code&gt;admin&lt;/code&gt; for authentication. This is also useful for databases where the user logs in against &lt;code&gt;admin&lt;/code&gt; but the path is used for selecting a database, for example, in the Database initializer.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mongodb://mongodb.example.com:12345/myDatabase?authSource=admin&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;authmechanism&#34;&gt;authMechanism&lt;/h3&gt;

&lt;p&gt;Selects a mechanism that will be used for authentication to the MongoDB server.&lt;/p&gt;

&lt;p&gt;MongoDB supports the following mechanisms:
- SCRAM_SHA_1
- MONGODB-CR
- MONGODB-X509
- GSSAP
- PLAIN&lt;/p&gt;

&lt;p&gt;MongoKitten only supports &lt;code&gt;SCRAM_SHA_1&lt;/code&gt; and &lt;code&gt;MONGODB-CR&lt;/code&gt;, currently.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Frequently Asked Questions</title>
      <link>http://docs.openkitten.org/reference/faq/</link>
      <pubDate>Wed, 14 Dec 2016 12:36:56 +0000</pubDate>
      
      <guid>http://docs.openkitten.org/reference/faq/</guid>
      <description></description>
    </item>
    
    <item>
      <title>GridFS</title>
      <link>http://docs.openkitten.org/tutorials/gridfs/</link>
      <pubDate>Wed, 14 Dec 2016 12:36:56 +0000</pubDate>
      
      <guid>http://docs.openkitten.org/tutorials/gridfs/</guid>
      <description>

&lt;h1 id=&#34;gridfs&#34;&gt;GridFS&lt;/h1&gt;

&lt;p&gt;GridFS is a standard for using MongoDB as file storage through the MongoDB binary type. MongoDB allows you to store documents up to 16MB in size, which is useful for storing PDFs, profile pictures and other binary data. But if you want to store bigger data than 16MB you&amp;rsquo;ll need to store it over multiple documents. GridFS fulfills that task.&lt;/p&gt;

&lt;h3 id=&#34;setup&#34;&gt;Setup&lt;/h3&gt;

&lt;p&gt;GridFS is a bucket consisting of two collections. This means that two collections have the same prefix separating their own bucket name with a dot (&lt;code&gt;.&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;GridFS uses the &lt;code&gt;fs&lt;/code&gt; prefix by default and then appends the bucket names &lt;code&gt;files&lt;/code&gt; and &lt;code&gt;chunks&lt;/code&gt; to create a &lt;code&gt;fs.files&lt;/code&gt; collection and &lt;code&gt;fs.chunks&lt;/code&gt; collection. Files stores the metadata, chunks stores the binary information for the files.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;let fs = db.makeGridFS()&lt;/code&gt; will get you the GridFS instance.&lt;/p&gt;

&lt;h2 id=&#34;using-gridfs&#34;&gt;Using GridFS&lt;/h2&gt;

&lt;p&gt;MongoKitten&amp;rsquo;s GridFS supports three methods of mutation.&lt;/p&gt;

&lt;p&gt;Create/store, Read/find and Remove/delete.&lt;/p&gt;

&lt;h3 id=&#34;storing-files&#34;&gt;Storing files&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let data: [UInt8] = []
let fileID = try fs.store(data: myData, named: &amp;quot;data.txt&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;removing-files&#34;&gt;Removing files&lt;/h3&gt;

&lt;p&gt;Files can only be removed by their identifier because you wouldn&amp;rsquo;t want to remove all files accidentally. For that we have &lt;code&gt;try fs.drop()&lt;/code&gt; which drops the collections.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;try fs.remove(byId: fileID)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;finding-files&#34;&gt;Finding files&lt;/h3&gt;

&lt;p&gt;This functions similarly to Collection. But instead of returning a cursor containing Documents it returns a &lt;code&gt;GridFS.File&lt;/code&gt; cursor.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let allFiles = try fs.find()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can find single files using findOne similarly to Collection.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let file: GridFS.File? = try fs.findOne(byID: fileID)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;reading-files&#34;&gt;Reading files&lt;/h3&gt;

&lt;p&gt;Once you&amp;rsquo;ve obtained an instance of &lt;code&gt;GridFS.File&lt;/code&gt; you&amp;rsquo;ve only fetched the metadata. Meaning the filename, mime type, MD5 checksum and any other metadata that this file contains.&lt;/p&gt;

&lt;p&gt;You can use this file instance to fetch either all or specific sets of bytes. In the case of a smaller download, or a download that&amp;rsquo;ll need to be served in it&amp;rsquo;s entirely.&lt;/p&gt;

&lt;p&gt;To fetch all bytes you&amp;rsquo;ll need to iterate over the chunks and send those chunks over the socket stream chunk-by-chunk.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;for chunk in file {
  socket.send(chunk.data)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can interrupt this process at any time efficiently without fetching extra data from MongoDB.&lt;/p&gt;

&lt;p&gt;MongoKitten will not throw an error when an error occurs when iterating over the file chunks using this method and will instead return no (additional) chunks. This may not always cause harm. In some situations it will result in an aborted or corrupted download which may or may not be a problem. In an image it&amp;rsquo;ll result in a partially loaded image, in a video it&amp;rsquo;ll result in the inability to load some parts of the movie and some file formats like PDF may be unable to open and need to be re-downloaded.&lt;/p&gt;

&lt;p&gt;If you want to set up a failsafe for these scenarios you&amp;rsquo;ll need to use the &lt;code&gt;try file.chunked()&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;for chunk in try file.chunked() {
  socket.send(chunk.data)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default most frameworks will be unable to serve the file properly which results in the same situation as above. But if you catch the error manually you may be able to fetch the remaining data by re-trying to fetch the remaining chunks. This can be useful when the used replica set or sharded cluster has had a failure because it&amp;rsquo;s been disabled for maintainance or another reason, or simply to log the problem.&lt;/p&gt;

&lt;h3 id=&#34;resumed-downloads&#34;&gt;Resumed downloads&lt;/h3&gt;

&lt;p&gt;Some larger files and web-browsers may use a functionality that allows resuming downloads. Videos use them for buffering, by downloading the relevant parts of the videos when required allowing you to start watching the first bit whilst the rest is still buffering. Other big files may use this web-feature for resuming big downloads after a connection problem has occurred. Or you may have another use case scenario.&lt;/p&gt;

&lt;p&gt;MongoKitten allows you to fetch specific subsets of information from GridFS.&lt;/p&gt;

&lt;p&gt;You can request all bytes after byte 1 million (1MB) for example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;try file.read(from: 1_000_000)`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can request a limited subset of bytes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;try file.read(from: 1_000_000, to: 2_500_000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This would fetch 1.5MB of data starting after 1MB.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Installation Guide</title>
      <link>http://docs.openkitten.org/installation-guide/installation-guide/</link>
      <pubDate>Wed, 14 Dec 2016 12:36:56 +0000</pubDate>
      
      <guid>http://docs.openkitten.org/installation-guide/installation-guide/</guid>
      <description>

&lt;h1 id=&#34;installation&#34;&gt;Installation&lt;/h1&gt;

&lt;p&gt;The recommended way to get started using the Swift driver is by using &lt;code&gt;SPM&lt;/code&gt; (Swift Package Manager) to install the dependency in your project.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>